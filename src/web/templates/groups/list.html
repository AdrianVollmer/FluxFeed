{% extends "base.html" %}

{% block title %}Groups - FluxFeed{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto">
    <div class="flex justify-between items-center mb-8">
        <div>
            <h1 class="text-3xl font-bold">Groups</h1>
            <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Drag the grip icon to reorganize (long-press on mobile), tap a group name to edit</p>
        </div>
        <button
            hx-get="/groups/new"
            hx-target="#group-form-modal"
            hx-swap="innerHTML"
            class="btn btn-primary">
            + Add Group
        </button>
    </div>

    <!-- Modal container -->
    <div id="group-form-modal"></div>

    <!-- Groups tree -->
    <div id="group-list" class="space-y-1">
        {% include "groups/_group_list_content.html" %}
    </div>
</div>

<script>
(function() {
    let draggedElement = null;
    let draggedType = null;
    let draggedId = null;

    // Touch drag state
    let touchDragActive = false;
    let touchStartTimer = null;
    let touchClone = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let currentDropTarget = null;
    const LONG_PRESS_DURATION = 300;
    const MOVE_THRESHOLD = 10;

    // Make drag handles draggable (desktop)
    function setupDraggable(handle) {
        handle.setAttribute('draggable', 'true');

        handle.addEventListener('dragstart', function(e) {
            draggedElement = handle;
            draggedType = handle.dataset.dragType;
            draggedId = handle.dataset.dragId;

            // Find the parent row and add opacity
            const row = handle.closest('.flex');
            if (row) row.classList.add('opacity-50');

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedId);

            // Set a custom drag image (optional)
            const dragImage = row || handle;
            e.dataTransfer.setDragImage(dragImage, 20, 20);
        });

        handle.addEventListener('dragend', function(e) {
            // Remove opacity from parent row
            const row = handle.closest('.flex');
            if (row) row.classList.remove('opacity-50');

            document.querySelectorAll('.drop-highlight').forEach(el => el.classList.remove('drop-highlight'));
            draggedElement = null;
            draggedType = null;
            draggedId = null;
        });

        // Touch events for mobile
        handle.addEventListener('touchstart', handleTouchStart, { passive: false });
        handle.addEventListener('touchmove', handleTouchMove, { passive: false });
        handle.addEventListener('touchend', handleTouchEnd);
        handle.addEventListener('touchcancel', handleTouchEnd);
    }

    function handleTouchStart(e) {
        const handle = e.currentTarget;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;

        // Start long-press timer
        touchStartTimer = setTimeout(function() {
            startTouchDrag(handle, touch);
        }, LONG_PRESS_DURATION);
    }

    function handleTouchMove(e) {
        const touch = e.touches[0];

        // If drag not active yet, check if moved too much (cancel long-press)
        if (!touchDragActive) {
            const dx = Math.abs(touch.clientX - touchStartX);
            const dy = Math.abs(touch.clientY - touchStartY);
            if (dx > MOVE_THRESHOLD || dy > MOVE_THRESHOLD) {
                clearTimeout(touchStartTimer);
            }
            return;
        }

        // Drag is active - prevent scrolling and move clone
        e.preventDefault();

        if (touchClone) {
            touchClone.style.left = (touch.clientX - 20) + 'px';
            touchClone.style.top = (touch.clientY - 20) + 'px';
        }

        // Find drop target under finger
        // Temporarily hide clone to get element underneath
        if (touchClone) touchClone.style.display = 'none';
        const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
        if (touchClone) touchClone.style.display = '';

        // Find the drop target
        const dropTarget = elementUnder ? elementUnder.closest('[data-drop-id]') : null;

        // Update highlights
        if (currentDropTarget && currentDropTarget !== dropTarget) {
            currentDropTarget.classList.remove('drop-highlight');
        }

        if (dropTarget) {
            // Don't highlight if dropping group on itself
            if (!(draggedType === 'group' && dropTarget.dataset.dropId === draggedId)) {
                dropTarget.classList.add('drop-highlight');
                currentDropTarget = dropTarget;
            }
        } else {
            currentDropTarget = null;
        }
    }

    function handleTouchEnd(e) {
        clearTimeout(touchStartTimer);

        if (!touchDragActive) {
            return;
        }

        // Perform drop if over a valid target
        if (currentDropTarget) {
            const targetGroupId = currentDropTarget.dataset.dropId;

            // Don't drop on self
            if (!(draggedType === 'group' && targetGroupId === draggedId)) {
                if (draggedType === 'feed') {
                    htmx.ajax('PUT', '/feeds/' + draggedId + '/group', {
                        target: '#group-list',
                        swap: 'innerHTML',
                        values: { group_id: targetGroupId || '' }
                    });
                } else if (draggedType === 'group') {
                    htmx.ajax('PUT', '/groups/' + draggedId + '/parent', {
                        target: '#group-list',
                        swap: 'innerHTML',
                        values: { parent_id: targetGroupId || '' }
                    });
                }
            }
            currentDropTarget.classList.remove('drop-highlight');
        }

        // Cleanup
        endTouchDrag();
    }

    function startTouchDrag(handle, touch) {
        touchDragActive = true;
        draggedElement = handle;
        draggedType = handle.dataset.dragType;
        draggedId = handle.dataset.dragId;

        // Add opacity to source row
        const row = handle.closest('.flex');
        if (row) row.classList.add('opacity-50');

        // Create floating clone
        const rowToClone = row || handle;
        touchClone = rowToClone.cloneNode(true);
        touchClone.classList.add('touch-drag-clone');
        touchClone.style.left = (touch.clientX - 20) + 'px';
        touchClone.style.top = (touch.clientY - 20) + 'px';
        document.body.appendChild(touchClone);

        // Haptic feedback if available
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }

    function endTouchDrag() {
        touchDragActive = false;

        // Remove opacity from source row
        if (draggedElement) {
            const row = draggedElement.closest('.flex');
            if (row) row.classList.remove('opacity-50');
        }

        // Remove clone
        if (touchClone) {
            touchClone.remove();
            touchClone = null;
        }

        // Clear highlights
        document.querySelectorAll('.drop-highlight').forEach(el => el.classList.remove('drop-highlight'));

        draggedElement = null;
        draggedType = null;
        draggedId = null;
        currentDropTarget = null;
    }

    // Make groups and ungrouped area drop targets (desktop)
    function setupDropTarget(el) {
        el.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Don't allow dropping a group onto itself
            if (draggedType === 'group' && el.dataset.dropId === draggedId) {
                return;
            }

            el.classList.add('drop-highlight');
        });

        el.addEventListener('dragleave', function(e) {
            // Only remove highlight if we're actually leaving this element
            if (!el.contains(e.relatedTarget)) {
                el.classList.remove('drop-highlight');
            }
        });

        el.addEventListener('drop', function(e) {
            e.preventDefault();
            el.classList.remove('drop-highlight');

            const targetGroupId = el.dataset.dropId;

            // Don't drop on self
            if (draggedType === 'group' && targetGroupId === draggedId) {
                return;
            }

            // Make the appropriate HTMX request
            if (draggedType === 'feed') {
                htmx.ajax('PUT', '/feeds/' + draggedId + '/group', {
                    target: '#group-list',
                    swap: 'innerHTML',
                    values: { group_id: targetGroupId || '' }
                });
            } else if (draggedType === 'group') {
                htmx.ajax('PUT', '/groups/' + draggedId + '/parent', {
                    target: '#group-list',
                    swap: 'innerHTML',
                    values: { parent_id: targetGroupId || '' }
                });
            }
        });
    }

    function initDragDrop() {
        // Setup draggable handles (only the grip icons)
        document.querySelectorAll('.drag-handle[data-drag-type]').forEach(setupDraggable);

        // Setup drop targets (groups and ungrouped area)
        document.querySelectorAll('[data-drop-id]').forEach(setupDropTarget);
    }

    // Initialize on page load
    initDragDrop();

    // Re-initialize after HTMX swaps
    document.body.addEventListener('htmx:afterSwap', function(e) {
        if (e.detail.target.id === 'group-list' || e.detail.target.closest('#group-list')) {
            initDragDrop();
        }
    });
})();
</script>

<style>
.drop-highlight {
    background-color: rgba(59, 130, 246, 0.1) !important;
    outline: 2px dashed #3B82F6;
    outline-offset: -2px;
}
.touch-drag-clone {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.9;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    padding: 0.5rem;
    max-width: 280px;
    transform: scale(0.95);
}
@media (prefers-color-scheme: dark) {
    .touch-drag-clone {
        background: #1f2937;
    }
}
</style>
{% endblock %}
